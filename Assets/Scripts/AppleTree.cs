using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AppleTree : MonoBehaviour
{
    //Extra notes:
    //Setting AppleTree's rigidbody to be kinematic makes obj not react to collisions
    //Put the apples generated into a physics layer since the appel still reacts to the tree
    //Physics layer: groups or obj's that can be made to only react/ignore with each other
    //Setting appletree and apple to separate physics layers disallows reactiosn from both of them

    [Header("Set in Inpsector")]
    public GameObject applePrefab;
    public float speed = 1f;
    public float leftAndRightEdge = 10f;
    public float chanceToChangeDirections = 0.1f;
    public float secondsBetweenAppleDrops = 1f;

    
    // Start is called before the first frame update
    void Start()
    {
        //Calls named function in a specific amount of seconds
        //2f is to wait 2 seconds before calling the dropApple function
        Invoke("DropApple", 2f);
    }

    // Update is called once per frame
    void Update()
    {
        Vector3 pos = transform.position; 
        pos.x += speed * Time.deltaTime; 
        //Time based movement makes sure that things move constantly on different framerates
        //Important aspect when developing mobile games
        transform.position = pos;
        //Not exactly a variable, but instead must use getters and setters to have any value
        
        if(pos.x < -leftAndRightEdge){
            speed = Mathf.Abs(speed); //Moves right
        } else if (pos.x > leftAndRightEdge){
            speed = -Mathf.Abs(speed); //Moves left
        } 
    }

    //Update function that is called 50 times per second
    void FixedUpdate() {
        if (Random.value < chanceToChangeDirections){
            //Uses random value generated by the random library
            //chancetoChange can be changed to make it harder by making the percentage higher
            //Although, too high would not allow it to move too far before changing directions
            //Chance is not based on time and so faster framerates would introduce more changes
            //Thays why it's moved to fixed update
            speed *= -1; //Change direction
        }
    }

    //Creates an instance of an apple prefab
    void DropApple(){
        GameObject apple = Instantiate<GameObject>(applePrefab);
        apple.transform.position = transform.position;
        //Calls itself and now its determined by secondsBetweenAppleDrops
        Invoke("DropApple", secondsBetweenAppleDrops);
    }
}
